<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>docco.nu</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>docco.nu</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        
            <tr>
                <td class='docs'><p><strong>Nucco</strong> is a quick-and-dirty, literate-programming-style documentation
generator -- as <a href="http://jashkenas.github.com/docco/">Docco</a>, <a href="http://rtomayko.github.com/shocco/">et</a> <a href="http://fitzgen.github.com/pycco/">al</a>. -- in and for <a href="http://programming.nu/">Nu</a>.</p>

<p>If you've seen them, you know what it does.</p>

<p>To use Nucco, you'll need Nu installed, as well as <a href="https://github.com/timburks/numarkdown">NuMarkdown</a>;
Download the <a href="https://github.com/andrewschleifer/nucco">Nucco source</a> and run <code>nuke install</code>, then you can use
<code>/usr/local/bin/nucco</code>, or <code>(load "Nucco:docco")</code> if you want to do it
yourself.</p>

                <td class='code'><pre>
</pre>
        
            <tr>
                <td class='docs'><p><em>TODO:</em></p>

<ul>
<li>Pygments doesn't speak Nu. Find something else to do syntax highlighting.</li>
<li>Nu is closely married to Objective-C. We should be able to handle <code>.m</code> files, too.</li>
<li>Special treatment for nudoc @metadata.</li>
</ul>

                <td class='code'><pre>

</pre>
        
            <tr>
                <td class='docs'><h3>Required Libraries</h3>

                <td class='code'><pre>
</pre>
        
            <tr>
                <td class='docs'><p>We use some utility functions and the templating library from the main Nu
framework and use NuMarkdown to format comments.</p>

                <td class='code'><pre>(load "Nu:nu")
(load "Nu:template")
(load "NuMarkdown:markdown")


</pre>
        
            <tr>
                <td class='docs'><h3>Support Functions</h3>

                <td class='code'><pre>
</pre>
        
            <tr>
                <td class='docs'><p>If there are Nu comment markers at the beginning of the string, remove them.</p>

                <td class='code'><pre>(function un-nu-comment (s)
    (/^\s*[#;]\s?/ replaceWithString:"" inString:s))

</pre>
        
            <tr>
                <td class='docs'><p>Predicate test for Nu-style comments.</p>

                <td class='code'><pre>(function nu-comment? (s)
    (cond
        ((/^\s*[#;]/ findInString:s) t)
        (else nil)))

</pre>
        
            <tr>
                <td class='docs'><p>Concatenate strings from a list, interleaving the requested separator.</p>

                <td class='code'><pre>(function with-concat (s ls)
    (cond
        ((null? ls) "")
        (else (+ (first ls) s (with-concat s (rest ls))))))

</pre>
        
            <tr>
                <td class='docs'><p>Divide a list into sub-lists, which alternately are <em>equivalent</em> or
<em>not-equivalent</em>, according to a predicate function. E.g. (1 2 3 3 4 4)
would become ((1) (2) (3 3) (4 4)) if we were testing with <code>even?</code>.</p>

                <td class='code'><pre>(function segregate-by (predicate ls)
    (cond
        ((null? ls) nil)
        (else (cons (match-with predicate ls)
                    (segregate-by predicate (excise-with predicate ls))))))

</pre>
        
            <tr>
                <td class='docs'><p>Accumulate atoms that are equivalent -- according to the predicate -- to the
first member of the list, until we locate a not-equivalent atom. This is
used in <code>segregate-by</code> to build sub-lists.</p>

                <td class='code'><pre>(function match-with (predicate ls)
    (cond
        ((null? ls) nil)
        ((null? (rest ls)) ls)
        ((eq (predicate (first ls)) (predicate (first (rest ls))))
            (cons (first ls) (match-with predicate (rest ls))))
        (else (list (first ls)))))

</pre>
        
            <tr>
                <td class='docs'><p>Discard atoms that are equivalent -- according to the predicate -- to the
first member of the list, until we locate a not-equivalent atom. This is
also used in <code>segregate-by</code>.</p>

                <td class='code'><pre>(function excise-with (predicate ls)
    (cond
        ((null? ls) nil)
        ((null? (rest ls)) nil)
        ((eq (predicate (first ls)) (predicate (first (rest ls))))
            (excise-with predicate (rest ls)))
        (else (rest ls))))

</pre>
        
            <tr>
                <td class='docs'><p>Apply functions in a list to corresponding values in a different list,
repeating the first list if necessary. In Nucco, we use it to apply
different formatting to comment and code.</p>

                <td class='code'><pre>(function looping-map (fs ls)
    (function sub-looping-map (sub-fs ls)
        (cond
            ((null? ls) nil)
            ((null? sub-fs) (sub-looping-map fs ls))
            (else (cons ((sub-fs first) (ls first))
                        (sub-looping-map (rest sub-fs) (rest ls))))))
    (sub-looping-map fs ls))


</pre>
        
            <tr>
                <td class='docs'><h3>Main Function</h3>

                <td class='code'><pre>
</pre>
        
            <tr>
                <td class='docs'><p>This is the main function. It takes a string of source code, builds a list
like (<em>"comment" "code" "comment" "code"</em>) and pours it into the
&lt;table&gt; of an HTML template.</p>

                <td class='code'><pre>(function docco (title string)
</pre>
        
            <tr>
                <td class='docs'><p>Split input into lines and build a list for recursing upon later.</p>

                <td class='code'><pre>    (set lines ((string lines) list))
</pre>
        
            <tr>
                <td class='docs'><p>Discard any shebang.</p>

                <td class='code'><pre>    (if (/^#!/ findInString:(lines first))
        (set lines (lines rest)))
</pre>
        
            <tr>
                <td class='docs'><p>Split the list into alternating comment/code sub-lists.</p>

                <td class='code'><pre>    (set lines (segregate-by nu-comment? lines))
</pre>
        
            <tr>
                <td class='docs'><p>We need matching pairs, so if the first line is code, insert a blank
comment before it.</p>

                <td class='code'><pre>    (unless (nu-comment? ((lines first) first))
        (set lines (cons (list ";") lines)))
</pre>
        
            <tr>
                <td class='docs'><p>Format the text by uncommenting, concatenating, and Markdown-ing lines
in comment sub-lists, while concatenating lines in code sub-lists.</p>

                <td class='code'><pre>    (set lines (looping-map
                (list
                    (do (x) (Markdown (with-concat "\n" (x map:un-nu-comment))))
                    (do (x) (with-concat "\n" x)))
                lines))
</pre>
        
            <tr>
                <td class='docs'><p>Load the template from our framework bundle and evaluate it. This will
parse and execute the code in the template and insert our data.</p>

                <td class='code'><pre>    (eval (NuTemplate codeForString:(NSString stringWithContentsOfFile:
        ((NSBundle frameworkWithName:"nucco") pathForResource:"docco" ofType:"nuhtml")
            encoding:NSUTF8StringEncoding error:nil))))
</pre>
        
    </tbody>
    </table>
</div>
</body>
</html>
